---
title: "How I created this blog using Nextjs"
publishedAt: "2024-04-09"
summary: "Describe how I created blog using Nextjs"
tags: ["software-engineering"]
---

I created this blog using [Portfolio Starter Kit](https://vercel.com/templates/next.js/portfolio-starter-kit) from Vercel.
The main functionality I added to it was filtering of the posts and theme
switcher. The posts themselves are written using MDX and stored as files on the filesystem.

The main structure of the blog is you have a server component
(`app/components/server/posts/index.tsx`) which retrieves the posts from the filesystem and
passes them as props to the client component
(`app/components/client/posts.tsx`) which renders the posts.

## Initial server-side filtering approach

Initially, I implemented filtering on the server side. The server
component would filter the blog posts based on the URL search parameters (using `getBlogPosts` function)
and forward the filtered results to the client component. The user then could
update the filter values using a multi-select component, which would
update the URL with the new filter values. This triggered a re-render of
the server component, which would then filter the posts again using the
updated query parameters and pass the filtered results back to the client.

## Why I switched to client side filtering

However, I realized that this approach could potentially cause multiple server
function invocations whenever the user interacted with the filters (each
time a filter changed, the server would have to perform filtering).
While this is usually fine, depending on your hosting plan, you might
want to limit the number of server function invocations.
Currently I am using Vercel Hobby plan, and they have limitations on such
function invocations.

To address this, I refactored the client component to handle filtering
locally using React state. In this updated version, the server component
simply retrieves _all_ blog posts and sends them to the client (the posts
being sent are reduced in size — they don’t include the full post
content — since we are just using them to generate links). This allows
the server component to be _statically generated_, avoiding server
function calls when the user filters posts.

## Keeping URL parameters in sync with filter UI

Even though filtering now happens on the client side, I still wanted our filter
panel to support URL parameters.

To achieve this, I chose to use the native History API (`history.pushState`) to update the URL with new filter values, instead of using `router.push` from `next/navigation`.

The main reason for this decision is that `router.push` triggers a server round-trip before updating the page. In our case, this likely wouldn’t be a big problem,
because our server component is statically generated — meaning no extra server function calls would occur. However, if the server component were dynamically rendered,
using `router.push` would cause all of its logic to run again.

Only after the server component finishes rendering would the client component update, which maybe undesirable in some cases.
The `useOptimistic` hook exists to help mitigate such issues. This [post](https://buildui.com/posts/instant-search-params-with-react-server-components) explores well how
to use `useOptimistic` to have url driven filter panels.

Finally, we also had now to keep track of URL changes, which I implemented by listening to the [popstate](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) event.
The `popstate` event will be triggered by doing a browser action such as a click on the back or forward button (or calling `history.back` or `history.forward` in JavaScript).
This event does not get triggered by `history.pushState` or `history.replaceState` calls but this is not a problem in our case.

## Sitemap and RSS

The starter kit also had a `app/sitemap.ts` file and an RSS route handler (`app/rss/route.ts`).
Both relied on the `getBlogPosts` function, which could potentially trigger additional server
function invocations. To avoid unnecessary invocations I added `export const dynamic = "force-static"` to both files.

## Adding theme switcher

I also added theme switcher to my blog. The starter kit already had
theme support in the sense that it was using tailwind classes like
`dark:text-white`. But it did not have the ability to manually switch
between themes. For this, I used the `next-themes` library, which takes
care of many common theme management tasks such as persisting the
selected theme in local storage, applying the appropriate dark or light
class to the HTML element, etc. The relevant implementation can be found
in `app/components/client/theme-toggle.tsx` client component.

Also, I would like to note that, the starter kit comes with packages
`tailwindcss` and `@tailwindcss/postcss` and both had version 4.0.0-alpha.13. I
had to upgrade them to versions 4.1.8 otherwise the themes were not
working.

## Final notes

Feel free to explore the [source code](https://github.com/gmoniava/personal-site) of this blog. I’ve also added
comments in the code to make it easier to follow the implementation. If
you're interested in the server-side filtering approach which I used initially, check out the
`server-side-filtering` branch.
