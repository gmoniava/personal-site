---
title: "How to Create a Blog in Next.js (my example)"
publishedAt: "2024-04-09"
summary: "Describe how I created blog using Nextjs."
tags: ["software-engineering"]
---

I created this blog using [Portfolio Starter Kit](https://vercel.com/templates/next.js/portfolio-starter-kit) from Vercel.
The main functionality I added to it was filtering of the posts and theme
switcher. The posts themselves are written using [MDX](https://mdxjs.com/) and stored as files on the filesystem.

The main structure of the blog is that a server component (`app/components/server/posts.tsx`) retrieves posts from
the filesystem and passes them as props to a client component (`app/components/client/posts.tsx`). The client
component generates links for each post, which the user can click to navigate to the individual post page implemented
in: `app/blog/[slug]/page.tsx`.

## Initial server-side filtering approach

Initially, I implemented filtering on the server side. The server
component would filter the blog posts based on the URL search parameters (using `getBlogPosts` function)
and forward the filtered results to the client component. The user then could
update the filter values using a multi-select component, which would
update the URL with the new filter values. This triggered a re-render of
the server component, which would then filter the posts again using the
updated query parameters and pass the filtered results back to the client.

## Why I switched to client side filtering

However, I realized that this approach could potentially cause multiple server
function invocations whenever the user interacted with the filters (each
time a filter changed, the server would have to perform filtering).
While this is usually fine, depending on your hosting plan, you might
want to limit the number of server function invocations.
Currently I am using Vercel Hobby plan, and they have limitations on such
function invocations.

To address this, I refactored the client component to handle filtering
locally using React state. In this updated version, the server component
simply retrieves _all_ blog posts and sends them to the client component (since
we are using these posts to generate links, we are not sending full version
of the posts). This allows the server component to be _statically rendered_, avoiding server
function invocation when the user filters posts.

## Keeping URL parameters in sync with filter UI

Even though filtering now happens on the client side, I still wanted our filter
panel to support URL parameters.

To achieve this, I chose to use the native History API (`history.pushState`) to update the URL with new filter values, instead of using `router.push` from `next/navigation`.

The main reason for this decision is that `router.push` triggers a server round-trip before updating the page.
This means the server must respond — which may involve a server component executing its logic — and only then
does React update the URL and display the new page. While this might not be a major issue in our case, it can
create a poor user experience when a client component’s UI depends on values returned by the server in response
to the new URL, since changes won’t be visible immediately.

There is hook [`useOptimistic`](https://react.dev/reference/react/useOptimistic) which can helps mitigate issues mentioned in the previous paragraph.
This [post](https://buildui.com/posts/instant-search-params-with-react-server-components)
offers a great exploration of how to use `useOptimistic` to build URL-driven filter panels which respond quickly to user actions.

Finally, we also had now to keep track of URL changes, which I implemented by listening to the [popstate](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) event.
The `popstate` event will be triggered by doing a browser action such as a click on the back or forward button (or calling `history.back` or `history.forward` in JavaScript).
This event does not get triggered by `history.pushState` or `history.replaceState` calls but this is not a problem in our case.

## Sitemap and RSS

The starter kit also had a `app/sitemap.ts` file and an RSS route handler (`app/rss/route.ts`).
Although the docs say this about the sitemap:

> sitemap.js is a special Route Handler that is cached by default unless it uses a Dynamic API or dynamic config option.

since both files relied on the `getBlogPosts` function, which could potentially trigger additional server
function invocations, I decided to add `export const dynamic = "force-static"` config [option](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config) to both files to err on the side of caution.

## Adding theme switcher

I also added theme switcher to my blog. The starter kit already had
theme support in the sense that it was using tailwind classes like
`dark:text-white`. But it did not have the ability to manually switch
between themes. For this, I used the `next-themes` library, which takes
care of many common theme management tasks such as persisting the
selected theme in local storage, applying the appropriate dark or light
class to the HTML element, etc. You still have to make the UI switcher component
which will switch the theme though. The relevant implementation can be found
in `app/components/client/theme-toggle.tsx` client component.

Also there is one thing you have to add to `global.css` to make the theme switcher work, which is
[this](https://tailwindcss.com/docs/dark-mode#toggling-dark-mode-manually): `@custom-variant dark (&:where(.dark, .dark *));`.

Finally, I would like to note that, the starter kit comes with packages
`tailwindcss` and `@tailwindcss/postcss` and both had version 4.0.0-alpha.13. I
had to upgrade them to versions 4.1.8 otherwise the themes were not
working.

## Implementation of page to view single blog post

The page which implements showing a single blog post is: `app/blog/[slug]/page.tsx`. You may notice the usage of `generateStaticParams`
function there. It is there to make sure each blog post is _statically_ rendered.

## Final notes

Feel free to explore the [source code](https://github.com/gmoniava/personal-site) of this blog. I’ve also added
comments in the code to make it easier to follow the implementation. If you're interested in the server-side
filtering approach which I used initially (which also contains `useOptimistic` based implementation of the
client component), check out the `server-side-filtering` branch.
